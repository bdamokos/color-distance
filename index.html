<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Color Distance Analysis</title>
    <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
    <style>
        .swatch {
            width: 50px;
            height: 50px;
            display: inline-block;
            margin: 5px;
            border: 1px solid #ccc;
        }
        .algorithm-section {
            margin: 20px;
            padding: 20px;
            border: 1px solid #ddd;
        }
        .metrics {
            font-family: monospace;
        }
        .control-panel {
            margin: 20px;
            padding: 20px;
            border: 1px solid #ddd;
            border-radius: 5px;
        }
        .input-group {
            margin: 10px 0;
        }
        .input-group label {
            margin-right: 10px;
        }
        button {
            padding: 10px 20px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }
        button:hover {
            background-color: #45a049;
        }
        .spinner {
            width: 50px;
            height: 50px;
            border: 5px solid #f3f3f3;
            border-top: 5px solid #3498db;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 20px auto;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        .processing {
            text-align: center;
            padding: 20px;
            background: rgba(255, 255, 255, 0.9);
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            border-radius: 10px;
            box-shadow: 0 0 10px rgba(0,0,0,0.2);
            z-index: 1000;
        }
        .algorithm-settings {
            margin: 10px 0;
            padding: 10px;
            border: 1px solid #eee;
            border-radius: 5px;
            display: none; /* Hidden by default */
            background-color: #f8f8f8; /* Light background */
            color: #333; /* Dark text */
        }
        .algorithm-settings h4 {
            margin: 0 0 10px 0;
            color: #333;
        }
        .algorithm-settings div {
            margin: 5px 0;
        }
        .algorithm-settings label {
            display: inline-block;
            width: 150px;
        }
        .algorithm-settings input {
            width: 100px;
        }
        .settings-toggle {
            background: #f0f0f0;
            border: 1px solid #ddd;
            padding: 10px;
            width: 100%;
            text-align: left;
            cursor: pointer;
            border-radius: 4px;
            margin: 5px 0;
            color: #333; /* Dark text */
        }
        
        .settings-toggle:hover {
            background: #e0e0e0;
        }
        
        .settings-toggle::after {
            content: '▼';
            float: right;
        }
        
        .settings-toggle.active::after {
            content: '▲';
        }
        
        .settings-container.show .algorithm-settings {
            display: block;
        }
        
        /* Add footer styles */
        .footer {
            margin-top: 40px;
            padding: 20px;
            text-align: center;
            border-top: 1px solid #ddd;
            color: #666;
            font-style: italic;
            font-size: 0.9em;
        }
        
        .swatch-container {
            display: flex;
            flex-wrap: wrap;
            max-width: 100%;
        }
        
        .processing .cancel-button {
            margin-top: 10px;
            padding: 5px 15px;
            background-color: #ff4444;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            display: none; /* Hidden by default */
        }
        
        .processing .cancel-button:hover {
            background-color: #cc0000;
        }
        
        /* Make rankings always appear at the bottom */
        .algorithm-section[data-type="summary"] {
            order: 999;
        }
        
        #results {
            display: flex;
            flex-direction: column;
        }
    </style>
</head>
<body>
    <div id="control-container"></div>
    <div id="initial-colors" class="algorithm-section"></div>
    <div id="results"></div>

    <div class="footer">
        This color analysis tool was generated with the assistance of Claude AI (Anthropic).
        <br>
        All algorithms and visualizations are powered by AI-assisted development.
        <br>
        <span style="font-size: 0.9em; color: #888;"> 
            <a href="https://bdamokos.github.io" style="color: #666; text-decoration: none;">More Projects</a> | 
            <a href="https://github.com/bdamokos/color-distance" style="color: #666; text-decoration: none;">Source Code</a>
        </span>
    </div>

    <script>
        // Convert RGB to Lab color space for delta E calculations
        function rgb2lab(rgb) {
            let r = rgb[0] / 255,
                g = rgb[1] / 255,
                b = rgb[2] / 255;

            r = r > 0.04045 ? Math.pow((r + 0.055) / 1.055, 2.4) : r / 12.92;
            g = g > 0.04045 ? Math.pow((g + 0.055) / 1.055, 2.4) : g / 12.92;
            b = b > 0.04045 ? Math.pow((b + 0.055) / 1.055, 2.4) : b / 12.92;

            let x = (r * 0.4124 + g * 0.3576 + b * 0.1805) * 100;
            let y = (r * 0.2126 + g * 0.7152 + b * 0.0722) * 100;
            let z = (r * 0.0193 + g * 0.1192 + b * 0.9505) * 100;

            x /= 95.047;
            y /= 100;
            z /= 108.883;

            x = x > 0.008856 ? Math.pow(x, 1/3) : (7.787 * x) + 16/116;
            y = y > 0.008856 ? Math.pow(y, 1/3) : (7.787 * y) + 16/116;
            z = z > 0.008856 ? Math.pow(z, 1/3) : (7.787 * z) + 16/116;

            return [(116 * y) - 16, 500 * (x - y), 200 * (y - z)];
        }

        // Calculate Delta E between two Lab colors
        function deltaE(labA, labB) {
            let deltaL = labA[0] - labB[0];
            let deltaA = labA[1] - labB[1];
            let deltaB = labA[2] - labB[2];
            return Math.sqrt(deltaL * deltaL + deltaA * deltaA + deltaB * deltaB);
        }

        // Generate random RGB color
        function randomColor() {
            return [
                Math.floor(Math.random() * 256),
                Math.floor(Math.random() * 256),
                Math.floor(Math.random() * 256)
            ];
        }

        // Convert RGB to hex
        function rgbToHex(rgb) {
            return '#' + rgb.map(x => {
                const hex = x.toString(16);
                return hex.length === 1 ? '0' + hex : hex;
            }).join('');
        }

        // Generate initial set of random colors
        let initialColors = Array.from({length: 50}, () => randomColor());

        // Calculate distance matrix
        function calculateDistanceMatrix(colors) {
            const labColors = colors.map(rgb2lab);
            const matrix = [];
            for (let i = 0; i < colors.length; i++) {
                matrix[i] = [];
                for (let j = 0; j < colors.length; j++) {
                    matrix[i][j] = deltaE(labColors[i], labColors[j]);
                }
            }
            return matrix;
        }

        // Method 1a: Maximum sum of distances (Global)
        function maxSumDistancesGlobal(colors, selectCount) {
            console.log('Starting Maximum Sum (Global) calculation...');
            const start = performance.now();
            const labColors = colors.map(rgb2lab);
            
            // Calculate the complete distance matrix once
            const distanceMatrix = Array(colors.length).fill(0).map(() => Array(colors.length).fill(0));
            for (let i = 0; i < colors.length; i++) {
                for (let j = i + 1; j < colors.length; j++) {
                    const dist = deltaE(labColors[i], labColors[j]);
                    distanceMatrix[i][j] = dist;
                    distanceMatrix[j][i] = dist;
                }
            }
            
            // Calculate total distances from each color to all other colors
            const totalDistances = distanceMatrix.map((row, i) => ({
                index: i,
                sum: row.reduce((a, b) => a + b, 0)
            }));
            
            // Sort colors by their total distance to all other colors
            totalDistances.sort((a, b) => b.sum - a.sum);
            
            // Simply take the top selectCount colors
            const selected = totalDistances.slice(0, selectCount).map(item => item.index);
            
            console.log('Maximum Sum (Global) calculation complete');
            return {
                colors: sortColors(selected.map(i => colors[i])),
                time: performance.now() - start
            };
        }

        // Method 2: Greedy algorithm
        function greedySelection(colors, selectCount) {
            console.log('Starting Greedy algorithm calculation...');
            const start = performance.now();
            const labColors = colors.map(rgb2lab);
            const selected = [0];
            
            while (selected.length < selectCount) {
                let maxMinDist = -1;
                let bestIndex = -1;
                
                for (let i = 0; i < colors.length; i++) {
                    if (selected.includes(i)) continue;
                    
                    let minDist = Infinity;
                    for (let j of selected) {
                        const dist = deltaE(labColors[i], labColors[j]);
                        minDist = Math.min(minDist, dist);
                    }
                    
                    if (minDist > maxMinDist) {
                        maxMinDist = minDist;
                        bestIndex = i;
                    }
                }
                
                selected.push(bestIndex);
            }
            
            console.log('Greedy algorithm calculation complete');
            return {
                colors: sortColors(selected.map(i => colors[i])),
                time: performance.now() - start
            };
        }

        // Method 3: Simulated Annealing
        function simulatedAnnealing(colors, selectCount) {
            console.log('Starting Simulated Annealing calculation...');
            const start = performance.now();
            const labColors = colors.map(rgb2lab);
            let current = Array.from({length: selectCount}, (_, i) => i);
            
            // Get configuration values
            const temp = parseFloat(document.getElementById('initialTemp').value);
            const coolingRate = parseFloat(document.getElementById('coolingRate').value);
            const minTemp = parseFloat(document.getElementById('minTemp').value);
            
            function getMinDistance(solution) {
                let minDist = Infinity;
                for (let i = 0; i < solution.length; i++) {
                    for (let j = i + 1; j < solution.length; j++) {
                        const dist = deltaE(labColors[solution[i]], labColors[solution[j]]);
                        minDist = Math.min(minDist, dist);
                    }
                }
                return minDist;
            }
            
            let currentScore = getMinDistance(current);
            let best = [...current];
            let bestScore = currentScore;
            let currentTemp = temp;
            
            while (currentTemp > minTemp) {
                const neighbor = [...current];
                const i = Math.floor(Math.random() * selectCount);
                let newColor;
                do {
                    newColor = Math.floor(Math.random() * colors.length);
                } while (neighbor.includes(newColor));
                neighbor[i] = newColor;
                
                const neighborScore = getMinDistance(neighbor);
                const delta = neighborScore - currentScore;
                
                if (delta > 0 || Math.random() < Math.exp(delta / currentTemp)) {
                    current = neighbor;
                    currentScore = neighborScore;
                    if (currentScore > bestScore) {
                        best = [...current];
                        bestScore = currentScore;
                    }
                }
                
                currentTemp *= coolingRate;
            }
            
            console.log('Simulated Annealing calculation complete');
            return {
                colors: sortColors(best.map(i => colors[i])),
                time: performance.now() - start
            };
        }

        // Method 4: Exact Minimum Distance (Brute Force)
        function exactMinimumDistance(colors, selectCount) {
            return new Promise((resolve, reject) => {
                console.log('Starting Exact Minimum Distance calculation...');
                const start = performance.now();
                
                const worker = createExactMinimumWorker();
                let lastProgress = 0;
                let timeoutId = null;
                let cancelled = false;
                let currentBest = null;  // Track current best solution
                
                worker.onmessage = function(e) {
                    if (cancelled) return;
                    
                    if (e.data.type === 'progress') {
                        const progress = e.data.progress;
                        currentBest = e.data.currentBest;  // Update current best
                        if (progress - lastProgress >= 1) {
                            showSpinner(
                                `Running Exact Minimum algorithm... ${progress.toFixed(1)}%`,
                                timeoutId !== null, // Show cancel button if timeout has occurred
                                () => {
                                    cancelled = true;
                                    worker.terminate();
                                    if (currentBest) {  // Use tracked current best
                                        resolve({
                                            colors: currentBest.map(i => colors[i]),
                                            time: performance.now() - start,
                                            cancelled: true,
                                            progress: progress
                                        });
                                    } else {
                                        reject(new Error('No solution found yet'));
                                    }
                                }
                            );
                            lastProgress = progress;
                        }
                    } else if (e.data.type === 'complete') {
                        const result = e.data.result;
                        worker.terminate();
                        if (timeoutId) clearTimeout(timeoutId);
                        resolve({
                            colors: result.selection.map(i => colors[i]),
                            time: result.time
                        });
                    } else if (e.data.type === 'error') {
                        worker.terminate();
                        if (timeoutId) clearTimeout(timeoutId);
                        reject(new Error(e.data.error));
                    }
                };

                worker.onerror = function(error) {
                    if (timeoutId) clearTimeout(timeoutId);
                    worker.terminate();
                    reject(new Error('Worker error: ' + (error.message || 'Unknown error')));
                };

                // Start the worker with initial data
                worker.postMessage({ colors, selectCount });

                // After 2 minutes, show cancel button but don't automatically cancel
                timeoutId = setTimeout(() => {
                    showSpinner(
                        `Running Exact Minimum algorithm... ${lastProgress.toFixed(1)}%`,
                        true,
                        () => {
                            cancelled = true;
                            worker.terminate();
                            if (currentBest) {  // Use tracked current best
                                resolve({
                                    colors: currentBest.map(i => colors[i]),
                                    time: performance.now() - start,
                                    cancelled: true,
                                    progress: lastProgress
                                });
                            } else {
                                reject(new Error('No solution found yet'));
                            }
                        }
                    );
                }, 120000);
            });
        }

        // Calculate metrics for a set of colors
        function calculateMetrics(colors) {
            const labColors = colors.map(rgb2lab);
            let minDist = Infinity;
            let maxDist = -Infinity;  // Add this to help verify calculations
            let sumDist = 0;
            let count = 0;
            
            // Calculate all pairwise distances
            for (let i = 0; i < colors.length; i++) {
                for (let j = i + 1; j < colors.length; j++) {
                    const dist = deltaE(labColors[i], labColors[j]);
                    minDist = Math.min(minDist, dist);
                    maxDist = Math.max(maxDist, dist);  // Track maximum distance
                    sumDist += dist;
                    count++;
                }
            }
            
            // Add debugging information
            console.log(`Metrics calculation:
                - Number of colors: ${colors.length}
                - Number of pairs: ${count}
                - Min distance: ${minDist.toFixed(2)}
                - Max distance: ${maxDist.toFixed(2)}
                - Sum of distances: ${sumDist.toFixed(2)}
                - Average distance: ${(sumDist / count).toFixed(2)}
            `);
            
            return {
                min: minDist,
                max: maxDist,  // Add this to the return object
                avg: sumDist / count,
                sum: sumDist,
                pairs: count   // Add this to help verify
            };
        }

        // Add this new function after calculateMetrics
        function findClosestPair(colors) {
            const labColors = colors.map(rgb2lab);
            let minDist = Infinity;
            let closestPair = [0, 1];
            
            for (let i = 0; i < colors.length; i++) {
                for (let j = i + 1; j < colors.length; j++) {
                    const dist = deltaE(labColors[i], labColors[j]);
                    if (dist < minDist) {
                        minDist = dist;
                        closestPair = [i, j];
                    }
                }
            }
            
            return {
                colors: [colors[closestPair[0]], colors[closestPair[1]]],
                distance: minDist
            };
        }

        // Create color spectrum plot
        function createSpectrumPlot(colors, elementId) {
            const labColors = colors.map(rgb2lab);
            const trace = {
                x: labColors.map(lab => lab[1]),  // a* component
                y: labColors.map(lab => lab[2]),  // b* component
                mode: 'markers',
                type: 'scatter',
                marker: {
                    size: 10,
                    color: colors.map(rgb => rgbToHex(rgb))
                }
            };

            const layout = {
                title: 'Color Distribution in Lab Color Space',
                xaxis: {title: 'a* (green-red)'},
                yaxis: {title: 'b* (blue-yellow)'}
            };

            Plotly.newPlot(elementId, [trace], layout);
        }

        // Update the analyzeColorDistribution function to handle large datasets
        function analyzeColorDistribution(colors) {
            if (!colors || colors.length === 0) return 'No colors to analyze';
            
            try {
                const labColors = colors.map(rgb2lab);
                
                // Initialize stats with first color to avoid Infinity comparisons
                const stats = {
                    L: { min: labColors[0][0], max: labColors[0][0], range: [0, 100] },
                    a: { min: labColors[0][1], max: labColors[0][1], range: [-128, 127] },
                    b: { min: labColors[0][2], max: labColors[0][2], range: [-128, 127] }
                };
                
                // Process colors in chunks to avoid stack overflow
                const chunkSize = 500;
                for (let i = 1; i < labColors.length; i += chunkSize) {
                    const chunk = labColors.slice(i, i + chunkSize);
                    for (const lab of chunk) {
                        stats.L.min = Math.min(stats.L.min, lab[0]);
                        stats.L.max = Math.max(stats.L.max, lab[0]);
                        stats.a.min = Math.min(stats.a.min, lab[1]);
                        stats.a.max = Math.max(stats.a.max, lab[1]);
                        stats.b.min = Math.min(stats.b.min, lab[2]);
                        stats.b.max = Math.max(stats.b.max, lab[2]);
                    }
                }
                
                // Calculate coverage percentages
                const coverage = {
                    L: ((stats.L.max - stats.L.min) / (stats.L.range[1] - stats.L.range[0]) * 100).toFixed(1),
                    a: ((stats.a.max - stats.a.min) / (stats.a.range[1] - stats.a.range[0]) * 100).toFixed(1),
                    b: ((stats.b.max - stats.b.min) / (stats.b.range[1] - stats.b.range[0]) * 100).toFixed(1)
                };
                
                // Calculate contrast ratios in chunks
                let maxContrast = -Infinity;
                let minContrast = Infinity;
                
                for (let i = 0; i < colors.length; i += chunkSize) {
                    const chunk1 = colors.slice(i, i + chunkSize);
                    for (let j = i; j < colors.length; j += chunkSize) {
                        const chunk2 = colors.slice(j, j + chunkSize);
                        for (const color1 of chunk1) {
                            for (const color2 of chunk2) {
                                if (color1 !== color2) {
                                    const contrast = calculateContrastRatio(color1, color2);
                                    maxContrast = Math.max(maxContrast, contrast);
                                    minContrast = Math.min(minContrast, contrast);
                                }
                            }
                        }
                    }
                }
                
                return `
                    <strong>Color Space Coverage:</strong><br>
                    Lightness (L*): ${coverage.L}%<br>
                    Green-Red (a*): ${coverage.a}%<br>
                    Blue-Yellow (b*): ${coverage.b}%<br>
                    <strong>Contrast Ratios:</strong><br>
                    Max: ${maxContrast.toFixed(2)}:1<br>
                    Min: ${minContrast.toFixed(2)}:1
                `;
            } catch (error) {
                console.error('Error in analyzeColorDistribution:', error);
                return 'Error analyzing color distribution';
            }
        }

        // Add helper functions for the enhanced analysis
        function calculateContrastRatio(rgb1, rgb2) {
            // Convert RGB to relative luminance
            function getLuminance(rgb) {
                const [r, g, b] = rgb.map(v => {
                    v = v / 255;
                    return v <= 0.03928 ? v / 12.92 : Math.pow((v + 0.055) / 1.055, 2.4);
                });
                return 0.2126 * r + 0.7152 * g + 0.0722 * b;
            }
            
            const l1 = getLuminance(rgb1);
            const l2 = getLuminance(rgb2);
            const lighter = Math.max(l1, l2);
            const darker = Math.min(l1, l2);
            
            return (lighter + 0.05) / (darker + 0.05);
        }

        // Sort colors by Lab values for consistent display
        function sortColors(colors) {
            const labColors = colors.map(rgb2lab);
            const indices = Array.from({length: colors.length}, (_, i) => i);
            
            // Sort by L, then a, then b
            indices.sort((i, j) => {
                const [L1, a1, b1] = labColors[i];
                const [L2, a2, b2] = labColors[j];
                if (L1 !== L2) return L2 - L1;
                if (a1 !== a2) return a2 - a1;
                return b2 - b1;
            });
            
            return indices.map(i => colors[i]);
        }

        // Modify the startCalculation function to properly handle async operations:
        async function startCalculation() {
            console.log('Starting calculation...');
            const totalColors = parseInt(document.getElementById('totalColors').value);
            const selectColors = parseInt(document.getElementById('selectColors').value);
            
            if (selectColors > totalColors) {
                alert('Number of colors to select cannot be greater than total colors');
                return;
            }

            // Clear previous results
            document.getElementById('results').innerHTML = '';
            document.getElementById('initial-colors').innerHTML = '';
            
            showSpinner('Generating initial colors...');
            
            // Use setTimeout to allow the spinner to render
            await new Promise(resolve => setTimeout(resolve, 0));
            
            console.log(`Generating ${totalColors} initial colors...`);
            initialColors = Array.from({length: totalColors}, () => randomColor());
            
            // Before creating initialHtml, sort the initial colors and calculate metrics
            const sortedInitialColors = sortColors(initialColors);
            const metrics = calculateMetrics(sortedInitialColors);
            const distribution = analyzeColorDistribution(sortedInitialColors);
            
            const initialHtml = `
                <h2>Initial Colors</h2>
                <div>
                    ${sortedInitialColors.map(rgb => 
                        `<div class="swatch" style="background-color: ${rgbToHex(rgb)}"></div>`
                    ).join('')}
                </div>
                <div class="metrics">
                    <p>Total Colors: ${totalColors}</p>
                    <p>Minimum deltaE: ${metrics.min.toFixed(2)}</p>
                    <div style="display: flex; align-items: center;">
                        <span>Closest pair: </span>
                        ${(() => {
                            const closest = findClosestPair(sortedInitialColors);
                            return closest.colors.map(rgb => 
                                `<div class="swatch" style="background-color: ${rgbToHex(rgb)}; margin: 0 5px;"></div>`
                            ).join('');
                        })()}
                        <span>(deltaE: ${findClosestPair(sortedInitialColors).distance.toFixed(2)})</span>
                    </div>
                    <p>Average deltaE: ${metrics.avg.toFixed(2)}</p>
                    <p>Sum deltaE: ${metrics.sum.toFixed(2)}</p>
                    <p>Distribution Analysis:<br/> ${distribution}</p>
                </div>
                <div id="initial-plot" style="width:600px;height:400px;"></div>
            `;
            
            document.getElementById('initial-colors').innerHTML = initialHtml;
            createSpectrumPlot(sortedInitialColors, 'initial-plot');
            
            hideSpinner();

            // Process each algorithm sequentially
            const selectedAlgorithms = {};
            document.querySelectorAll('input[type="checkbox"]').forEach(checkbox => {
                if (checkbox.checked) {
                    // Convert checkbox ID back to algorithm name
                    const algorithmId = checkbox.id.replace('algo-', '');
                    const algorithmName = algorithmId
                        .split('-')
                        .map(word => word.charAt(0).toUpperCase() + word.slice(1))
                        .join(' ');
                    
                    switch(algorithmName) {
                        case 'Maximum Sum Global':  
                            selectedAlgorithms[algorithmName] = () => maxSumDistancesGlobal(initialColors, selectColors);
                            break;
                        case 'Maximum Sum Sequential':  
                            selectedAlgorithms[algorithmName] = () => maxSumDistancesSequential(initialColors, selectColors);
                            break;
                        case 'Greedy':
                            selectedAlgorithms[algorithmName] = () => greedySelection(initialColors, selectColors);
                            break;
                        case 'Simulated Annealing':
                            selectedAlgorithms[algorithmName] = () => simulatedAnnealing(initialColors, selectColors);
                            break;
                        case 'K Means':
                            selectedAlgorithms[algorithmName] = () => kmeansppSelection(initialColors, selectColors);
                            break;
                        case 'Genetic Algorithm':
                            selectedAlgorithms[algorithmName] = () => geneticAlgorithm(initialColors, selectColors);
                            break;
                        case 'Particle Swarm':
                            selectedAlgorithms[algorithmName] = () => particleSwarmOptimization(initialColors, selectColors);
                            break;
                        case 'Ant Colony':
                            selectedAlgorithms[algorithmName] = () => antColonyOptimization(initialColors, selectColors);
                            break;
                        case 'Tabu Search':
                            selectedAlgorithms[algorithmName] = () => tabuSearch(initialColors, selectColors);
                            break;
                        case 'Exact Minimum':
                            selectedAlgorithms[algorithmName] = () => exactMinimumDistance(initialColors, selectColors);
                            break;
                    }
                }
            });

            // Now process the selected algorithms
            for (const [name, algorithm] of Object.entries(selectedAlgorithms)) {
                showSpinner(`Running ${name} algorithm...`);
                // Allow spinner to render
                await new Promise(resolve => setTimeout(resolve, 0));
                
                try {
                    const result = await Promise.resolve(algorithm());
                    hideSpinner();
                    
                    const metrics = calculateMetrics(result.colors);
                    const distribution = analyzeColorDistribution(result.colors);
                    const plotId = `plot-${name.toLowerCase().replace(/\s+/g, '-')}`;
                    
                    const algorithmContainer = document.createElement('div');
                    algorithmContainer.className = 'algorithm-section';
                    algorithmContainer.innerHTML = `
                        <h2>${name}</h2>
                        <div class="swatch-container">
                            ${result.colors.map(rgb => 
                                `<div class="swatch" style="background-color: ${rgbToHex(rgb)}"></div>`
                            ).join('')}
                        </div>
                        <div class="metrics">
                            <p>Execution time: ${formatExecutionTime(result.time)}</p>
                            <p>Minimum deltaE: ${metrics.min.toFixed(2)}</p>
                            <div style="display: flex; align-items: center;">
                                <span>Closest pair: </span>
                                ${(() => {
                                    const closest = findClosestPair(result.colors);
                                    return closest.colors.map(rgb => 
                                        `<div class="swatch" style="background-color: ${rgbToHex(rgb)}; margin: 0 5px;"></div>`
                                    ).join('');
                                })()}
                                <span>(deltaE: ${findClosestPair(result.colors).distance.toFixed(2)})</span>
                            </div>
                            <p>Average deltaE: ${metrics.avg.toFixed(2)}</p>
                            <p>Sum deltaE: ${metrics.sum.toFixed(2)}</p>
                            <p>Distribution Analysis: ${distribution}</p>
                        </div>
                        <div id="${plotId}" style="width:600px;height:400px;"></div>
                        <div class="algorithm-explanation" style="margin-top: 20px; padding: 10px; background: #f5f5f5; border-radius: 5px;">
                            <h4 style="margin-top: 0;">How ${name} works:</h4>
                            <p>${getAlgorithmExplanation(name)}</p>
                        </div>
                    `;
                    
                    document.getElementById('results').appendChild(algorithmContainer);
                    createSpectrumPlot(result.colors, plotId);
                    
                    // Update rankings after each algorithm completes
                    updateRankings();
                    
                } catch (error) {
                    hideSpinner();
                    console.error(`Error in ${name} algorithm:`, error);
                    const errorContainer = document.createElement('div');
                    errorContainer.className = 'algorithm-section';
                    errorContainer.innerHTML = `
                        <h2>${name}</h2>
                        <p style="color: red;">Error: ${error.message}</p>
                    `;
                    document.getElementById('results').appendChild(errorContainer);
                }
            }

            console.log('All calculations complete!');
        }

        // Add console logging to the algorithm functions
        function maxSumDistancesSequential(colors, selectCount) {
            console.log('Starting Maximum Sum (Sequential) calculation...');
            const start = performance.now();
            const labColors = colors.map(rgb2lab);
            
            // Calculate the complete distance matrix once
            const distanceMatrix = Array(colors.length).fill(0).map(() => Array(colors.length).fill(0));
            for (let i = 0; i < colors.length; i++) {
                for (let j = i + 1; j < colors.length; j++) {
                    const dist = deltaE(labColors[i], labColors[j]);
                    distanceMatrix[i][j] = dist;
                    distanceMatrix[j][i] = dist;
                }
            }
            
            // Calculate total distances from each color to all other colors
            const totalDistances = distanceMatrix.map((row, i) => ({
                index: i,
                sum: row.reduce((a, b) => a + b, 0)
            }));
            
            // Sort colors by their total distance to all other colors
            totalDistances.sort((a, b) => b.sum - a.sum);
            
            // Take the top selectCount colors that have the highest total distances
            // but also ensure they're reasonably distant from each other
            const selected = [totalDistances[0].index];
            const candidates = totalDistances.slice(1);
            
            while (selected.length < selectCount && candidates.length > 0) {
                // Find the candidate that has the highest sum of distances to selected colors
                let bestIdx = 0;
                let bestScore = -Infinity;
                
                for (let i = 0; i < candidates.length; i++) {
                    const candidateIdx = candidates[i].index;
                    const score = selected.reduce((sum, selectedIdx) => 
                        sum + distanceMatrix[candidateIdx][selectedIdx], 0);
                    
                    if (score > bestScore) {
                        bestScore = score;
                        bestIdx = i;
                    }
                }
                
                selected.push(candidates[bestIdx].index);
                candidates.splice(bestIdx, 1);
            }
            
            console.log('Maximum Sum (Sequential) calculation complete');
            return {
                colors: sortColors(selected.map(i => colors[i])),
                time: performance.now() - start
            };
        }

        // Similar console.log statements for other algorithm functions...

        // Add these functions after initializePage
        function showSpinner(message = 'Processing...', showCancel = false, onCancel = null) {
            hideSpinner();
            
            const spinner = document.createElement('div');
            spinner.id = 'processingSpinner';
            spinner.className = 'processing';
            spinner.innerHTML = `
                <div class="spinner"></div>
                <div>${message}</div>
                ${showCancel ? '<button class="cancel-button">Cancel This Algorithm</button>' : ''}
            `;
            document.body.appendChild(spinner);
            
            const cancelButton = spinner.querySelector('.cancel-button');
            if (cancelButton && onCancel) {
                cancelButton.style.display = 'block';
                cancelButton.onclick = onCancel;
            }
        }

        function hideSpinner() {
            const spinner = document.getElementById('processingSpinner');
            if (spinner) {
                spinner.remove();
            }
        }

        // Add this function to measure the machine's performance
        function calibratePerformance() {
            return new Promise(resolve => {
                const workerCode = `
                    function* combinations(n, r) {
                        const indices = Array(r).fill(0);
                        let i = 0;
                        while (i < r) {
                            indices[i] = i;
                            i++;
                        }
                        yield indices.slice();
                        while (true) {
                            i = r - 1;
                            while (i >= 0 && indices[i] >= n - r + i) {
                                i--;
                            }
                            if (i < 0) {
                                return;
                            }
                            indices[i]++;
                            for (let j = i + 1; j < r; j++) {
                                indices[j] = indices[j - 1] + 1;
                            }
                            yield indices.slice();
                        }
                    }

                    function measureSpeed() {
                        const start = performance.now();
                        let count = 0;
                        const testCases = [
                            { n: 20, r: 5, samples: 2000 },  // Small case
                            { n: 30, r: 10, samples: 2000 }, // Medium case
                            { n: 40, r: 15, samples: 1000 }  // Larger case
                        ];
                        
                        let totalTime = 0;
                        let totalCombinations = 0;

                        for (const testCase of testCases) {
                            const testStart = performance.now();
                            for (const combo of combinations(testCase.n, testCase.r)) {
                                count++;
                                // Simulate the actual calculation work
                                let minDist = Infinity;
                                for (let i = 0; i < combo.length; i++) {
                                    for (let j = i + 1; j < combo.length; j++) {
                                        const dist = Math.abs(combo[i] - combo[j]);
                                        minDist = Math.min(minDist, dist);
                                    }
                                }
                                if (count >= testCase.samples) break;
                            }
                            const testTime = performance.now() - testStart;
                            totalTime += testTime;
                            totalCombinations += testCase.samples;
                        }
                        
                        return (totalCombinations / (totalTime / 1000)); // combinations per second
                    }

                    self.onmessage = function() {
                        const speed = measureSpeed();
                        self.postMessage(speed);
                    };
                `;

                const blob = new Blob([workerCode], { type: 'application/javascript' });
                const worker = new Worker(URL.createObjectURL(blob));
                
                worker.onmessage = function(e) {
                    worker.terminate();
                    resolve(e.data);
                };
                
                worker.postMessage({});
            });
        }

        // Modify initializePage to include calibration
        async function initializePage() {
            const controlHtml = `
                <div class="control-panel">
                    <div class="input-group">
                        <label for="totalColors">Number of colors to generate:</label>
                        <input type="number" id="totalColors" value="30" min="10" max="1000">
                    </div>
                    <div class="input-group">
                        <label for="selectColors">Number of colors to select:</label>
                        <input type="number" id="selectColors" value="10" min="2">
                    </div>
                    
                    <div class="input-group" style="border-top: 1px solid #ddd; padding-top: 10px; margin-top: 10px;">
                        <h3 style="margin: 0 0 10px 0;">Algorithm Selection</h3>
                        <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 10px;">
                            <div>
                                <input type="checkbox" id="algo-maximum-sum-global" checked>
                                <label for="algo-maximum-sum-global">Maximum Sum Global</label>
                            </div>
                            <div>
                                <input type="checkbox" id="algo-maximum-sum-sequential" checked>
                                <label for="algo-maximum-sum-sequential">Maximum Sum Sequential</label>
                            </div>
                            <div>
                                <input type="checkbox" id="algo-greedy" checked>
                                <label for="algo-greedy">Greedy</label>
                            </div>
                            <div>
                                <input type="checkbox" id="algo-simulated-annealing" checked>
                                <label for="algo-simulated-annealing">Simulated Annealing</label>
                            </div>
                            <div>
                                <input type="checkbox" id="algo-k-means" checked>
                                <label for="algo-k-means">K-Means++</label>
                            </div>
                            <div>
                                <input type="checkbox" id="algo-genetic-algorithm">
                                <label for="algo-genetic-algorithm">Genetic Algorithm</label>
                            </div>
                            <div>
                                <input type="checkbox" id="algo-particle-swarm">
                                <label for="algo-particle-swarm">Particle Swarm</label>
                            </div>
                            <div>
                                <input type="checkbox" id="algo-ant-colony">
                                <label for="algo-ant-colony">Ant Colony</label>
                            </div>
                            <div>
                                <input type="checkbox" id="algo-tabu-search">
                                <label for="algo-tabu-search">Tabu Search</label>
                            </div>
                            <div>
                                <input type="checkbox" id="algo-exact-minimum" checked>
                                <label for="algo-exact-minimum">Exact Minimum</label>
                            </div>
                        </div>
                    </div>

                    <div class="input-group" style="border-top: 1px solid #ddd; padding-top: 10px; margin-top: 10px;">
                        <h3 style="margin: 0 0 10px 0;">Algorithm Settings</h3>
                        <button class="settings-toggle" onclick="toggleSettings(this)">Show Settings</button>
                        <div class="settings-container">
                            <!-- Simulated Annealing Settings -->
                            <div class="algorithm-settings" id="settings-annealing">
                                <h4>Simulated Annealing</h4>
                                <div>
                                    <label for="initialTemp">Initial Temperature:</label>
                                    <input type="number" id="initialTemp" value="1000" min="1">
                                </div>
                                <div>
                                    <label for="coolingRate">Cooling Rate (0-1):</label>
                                    <input type="number" id="coolingRate" value="0.995" min="0" max="1" step="0.001">
                                </div>
                                <div>
                                    <label for="minTemp">Minimum Temperature:</label>
                                    <input type="number" id="minTemp" value="0.1" min="0.0001" step="0.1">
                                </div>
                            </div>

                            <!-- Genetic Algorithm Settings -->
                            <div class="algorithm-settings" id="settings-genetic">
                                <h4>Genetic Algorithm</h4>
                                <div>
                                    <label for="populationSize">Population Size:</label>
                                    <input type="number" id="populationSize" value="100" min="10">
                                </div>
                                <div>
                                    <label for="generations">Generations:</label>
                                    <input type="number" id="generations" value="100" min="10">
                                </div>
                                <div>
                                    <label for="mutationRate">Mutation Rate:</label>
                                    <input type="number" id="mutationRate" value="0.1" min="0" max="1" step="0.01">
                                </div>
                            </div>

                            <!-- PSO Settings -->
                            <div class="algorithm-settings" id="settings-pso">
                                <h4>Particle Swarm Optimization</h4>
                                <div>
                                    <label for="numParticles">Number of Particles:</label>
                                    <input type="number" id="numParticles" value="30" min="5">
                                </div>
                                <div>
                                    <label for="psoIterations">Iterations:</label>
                                    <input type="number" id="psoIterations" value="100" min="10">
                                </div>
                            </div>

                            <!-- ACO Settings -->
                            <div class="algorithm-settings" id="settings-aco">
                                <h4>Ant Colony Optimization</h4>
                                <div>
                                    <label for="numAnts">Number of Ants:</label>
                                    <input type="number" id="numAnts" value="20" min="5">
                                </div>
                                <div>
                                    <label for="acoIterations">Iterations:</label>
                                    <input type="number" id="acoIterations" value="50" min="10">
                                </div>
                            </div>

                            <!-- Tabu Search Settings -->
                            <div class="algorithm-settings" id="settings-tabu">
                                <h4>Tabu Search</h4>
                                <div>
                                    <label for="tabuIterations">Maximum Iterations:</label>
                                    <input type="number" id="tabuIterations" value="1000" min="100">
                                </div>
                                <div>
                                    <label for="tabuTenure">Tabu Tenure:</label>
                                    <input type="number" id="tabuTenure" value="5" min="1">
                                </div>
                            </div>
                        </div>
                    </div>

                    <button onclick="startCalculation()">Generate and Calculate</button>
                    <div id="complexityEstimate" style="margin-top: 10px; font-style: italic;"></div>
                </div>
            `;
            
            document.getElementById('control-container').innerHTML = controlHtml;
            
            // Calibrate performance
            showSpinner('Calibrating performance...');
            const combinationsPerSecond = await calibratePerformance();
            hideSpinner();
            
            // Store the calibrated speed as a global variable
            window.calibratedSpeed = combinationsPerSecond;
            
            // Add event listeners to update complexity estimate when values change
            document.getElementById('totalColors').addEventListener('input', updateComplexityEstimate);
            document.getElementById('selectColors').addEventListener('input', updateComplexityEstimate);
            updateComplexityEstimate(); // Initial estimate
        }

        // Add this new function to format time estimates
        function formatTimeEstimate(seconds) {
            if (seconds < 1) return 'less than a second';
            
            const timeUnits = [
                { unit: 'millennium', plural: 'millennia', seconds: 31557600000 },
                { unit: 'century', plural: 'centuries', seconds: 3155760000 },
                { unit: 'decade', plural: 'decades', seconds: 315576000 },
                { unit: 'year', plural: 'years', seconds: 31557600 },
                { unit: 'month', plural: 'months', seconds: 2629800 },
                { unit: 'week', plural: 'weeks', seconds: 604800 },
                { unit: 'day', plural: 'days', seconds: 86400 },
                { unit: 'hour', plural: 'hours', seconds: 3600 },
                { unit: 'minute', plural: 'minutes', seconds: 60 },
                { unit: 'second', plural: 'seconds', seconds: 1 }
            ];

            // Find the two largest applicable units
            let primaryUnit = timeUnits.find(unit => seconds >= unit.seconds);
            if (!primaryUnit) return 'less than a second';

            const primaryValue = Math.floor(seconds / primaryUnit.seconds);
            const remainingSeconds = seconds % primaryUnit.seconds;

            // Find the next unit down that has a value
            const secondaryUnit = timeUnits.find(unit => 
                unit.seconds < primaryUnit.seconds && remainingSeconds >= unit.seconds
            );

            let timeString = `${primaryValue} ${primaryValue === 1 ? primaryUnit.unit : primaryUnit.plural}`;
            
            if (secondaryUnit) {
                const secondaryValue = Math.floor(remainingSeconds / secondaryUnit.seconds);
                if (secondaryValue > 0) {
                    timeString += ` and ${secondaryValue} ${secondaryValue === 1 ? secondaryUnit.unit : secondaryUnit.plural}`;
                }
            }

            return timeString;
        }

        // Modify updateComplexityEstimate to use the new time formatting
        function updateComplexityEstimate() {
            const n = parseInt(document.getElementById('totalColors').value);
            const r = parseInt(document.getElementById('selectColors').value);
            
            // Calculate number of combinations (n choose r)
            let combinations = 1;
            for (let i = 0; i < r; i++) {
                combinations *= (n - i) / (i + 1);
            }
            
            // Use calibrated speed if available, otherwise use default estimate
            const combinationsPerSecond = window.calibratedSpeed || 100000;
            const estimatedSeconds = combinations / combinationsPerSecond;
            
            const timeString = formatTimeEstimate(estimatedSeconds);
            
            const complexityDiv = document.getElementById('complexityEstimate');
            complexityDiv.innerHTML = `
                <p>Exact Minimum calculation will check ${combinations.toLocaleString()} combinations</p>
                <p>Estimated time: ${timeString}</p>
                ${estimatedSeconds > 120 ? '<p style="color: orange;">Warning: This might take a while!</p>' : ''}
                <p style="font-size: 0.8em;">Based on measured performance: ~${Math.round(combinationsPerSecond).toLocaleString()} combinations/second</p>
            `;
        }

        // Add this new function to provide the explanations
        function getAlgorithmExplanation(algorithmName) {
            const explanations = {
                'Maximum Sum Global': 
                    'This algorithm calculates the total deltaE distance from each color to all other colors in the ' +
                    'initial set, then selects the N colors that have the highest total distances globally. Colors with ' +
                    'high deltaE distances to many other colors in the complete set are selected, optimizing for colors ' +
                    'that are generally different from the entire set.',
                
                'Maximum Sum Sequential': 
                    'This algorithm uses a sequential selection process. It first calculates total distances and picks the ' +
                    'color with the highest global distance. Then, for each subsequent selection, it chooses the color that ' +
                    'maximizes the sum of distances to only the previously selected colors, building the palette one color ' +
                    'at a time.',
                
                'Greedy': 
                    'Starting with the first color, this algorithm iteratively selects the color that has the maximum minimum ' +
                    'distance to all previously selected colors. It builds the solution step by step, making the locally optimal ' +
                    'choice at each step. While not guaranteed to find the global optimum, it usually produces good results quickly.',
                
                'Simulated Annealing': 
                    'This is a probabilistic optimization algorithm inspired by the annealing process in metallurgy. It starts with ' +
                    'a random selection and iteratively makes small changes, accepting improvements and occasionally accepting worse ' +
                    'solutions based on a decreasing "temperature" parameter. This allows it to escape local optima and potentially ' +
                    'find better solutions than greedy approaches.',
                
                'K Means': 
                    'This algorithm uses the k-means++ initialization strategy to select diverse colors. It starts by randomly ' +
                    'selecting one color, then iteratively chooses subsequent colors with probability proportional to their squared ' +
                    'distance from the nearest already-selected color. This tends to produce well-distributed selections quickly.',
                
                'Genetic Algorithm': 
                    'Inspired by natural evolution, this algorithm maintains a population of potential solutions and evolves them ' +
                    'through selection, crossover, and mutation operations. Solutions with better minimum distances between colors ' +
                    'are more likely to survive and produce offspring, leading to increasingly better selections over generations.',
                
                'Particle Swarm': 
                    'Based on swarm intelligence, this algorithm simulates particles moving through the solution space. Each particle ' +
                    'adjusts its trajectory based on its own best known position and the swarm\'s best known position. This social ' +
                    'behavior helps particles converge on optimal color selections.',
                
                'Ant Colony': 
                    'This algorithm simulates how ants find optimal paths using pheromone trails. Virtual ants construct solutions ' +
                    'by selecting colors, leaving pheromone trails proportional to solution quality. Over time, stronger trails ' +
                    'emerge for better color combinations, guiding future selections.',
                
                'Tabu Search': 
                    'This algorithm uses memory structures (tabu lists) to guide a local search procedure. It prevents cycling back ' +
                    'to recently visited solutions by maintaining a list of forbidden moves, while allowing the search to escape ' +
                    'local optima through strategic acceptance of non-improving moves.',
                
                'Exact Minimum': 
                    'This algorithm performs an exhaustive search through all possible combinations of colors to find the globally ' +
                    'optimal solution. It guarantees finding the best possible selection but becomes computationally intensive for ' +
                    'large sets. It has a time complexity of O(n choose k), where n is the total number of colors and k is the ' +
                    'number of colors to select.'
            };
            
            return explanations[algorithmName] || 'No explanation available for this algorithm.';
        }

        // First, add this new function at the end of the script section:
        function createExactMinimumWorker() {
            const workerCode = `
                // Helper function to sleep
                function sleep(ms) {
                    return new Promise(resolve => setTimeout(resolve, ms));
                }

                // Convert RGB to Lab color space for delta E calculations
                function rgb2lab(rgb) {
                    let r = rgb[0] / 255,
                        g = rgb[1] / 255,
                        b = rgb[2] / 255;

                    r = r > 0.04045 ? Math.pow((r + 0.055) / 1.055, 2.4) : r / 12.92;
                    g = g > 0.04045 ? Math.pow((g + 0.055) / 1.055, 2.4) : g / 12.92;
                    b = b > 0.04045 ? Math.pow((b + 0.055) / 1.055, 2.4) : b / 12.92;

                    let x = (r * 0.4124 + g * 0.3576 + b * 0.1805) * 100;
                    let y = (r * 0.2126 + g * 0.7152 + b * 0.0722) * 100;
                    let z = (r * 0.0193 + g * 0.1192 + b * 0.9505) * 100;

                    x /= 95.047;
                    y /= 100;
                    z /= 108.883;

                    x = x > 0.008856 ? Math.pow(x, 1/3) : (7.787 * x) + 16/116;
                    y = y > 0.008856 ? Math.pow(y, 1/3) : (7.787 * y) + 16/116;
                    z = z > 0.008856 ? Math.pow(z, 1/3) : (7.787 * z) + 16/116;

                    return [(116 * y) - 16, 500 * (x - y), 200 * (y - z)];
                }

                function deltaE(labA, labB) {
                    let deltaL = labA[0] - labB[0];
                    let deltaA = labA[1] - labB[1];
                    let deltaB = labA[2] - labB[2];
                    return Math.sqrt(deltaL * deltaL + deltaA * deltaA + deltaB * deltaB);
                }

                function* combinations(arr, r) {
                    const n = arr.length;
                    const indices = Array(r).fill(0);
                    let i = 0;
                    while (i < r) {
                        indices[i] = i;
                        i++;
                    }
                    yield indices.slice();
                    while (true) {
                        i = r - 1;
                        while (i >= 0 && indices[i] >= n - r + i) {
                            i--;
                        }
                        if (i < 0) {
                            return;
                        }
                        indices[i]++;
                        for (let j = i + 1; j < r; j++) {
                            indices[j] = indices[j - 1] + 1;
                        }
                        yield indices.slice();
                    }
                }

                async function processColors(colors, selectCount) {
                    try {
                        const start = performance.now();
                        const labColors = colors.map(rgb2lab);
                        let bestSelection = null;
                        let maxMinDist = -1;
                        let combinationsChecked = 0;
                        let totalCombinations = 1;

                        // Calculate total combinations correctly
                        for (let i = 0; i < selectCount; i++) {
                            totalCombinations *= (colors.length - i) / (i + 1);
                        }
                        // Round to handle floating point precision issues
                        totalCombinations = Math.round(totalCombinations);

                        for (const combo of combinations([...Array(colors.length).keys()], selectCount)) {
                            combinationsChecked++;
                            
                            // Report progress every 1000 combinations
                            if (combinationsChecked % 1000 === 0) {
                                // Ensure progress never exceeds 100%
                                const progress = Math.min((combinationsChecked / totalCombinations) * 100, 100);
                                self.postMessage({ 
                                    type: 'progress', 
                                    progress,
                                    currentBest: bestSelection
                                });
                            }

                            let minDist = Infinity;
                            for (let i = 0; i < combo.length; i++) {
                                for (let j = i + 1; j < combo.length; j++) {
                                    const dist = deltaE(labColors[combo[i]], labColors[combo[j]]);
                                    minDist = Math.min(minDist, dist);
                                }
                            }
                            if (minDist > maxMinDist) {
                                maxMinDist = minDist;
                                bestSelection = combo;
                            }

                            if (combinationsChecked % 10000 === 0) {
                                await sleep(0);
                            }
                        }

                        return {
                            selection: bestSelection,
                            time: performance.now() - start
                        };
                    } catch (error) {
                        throw new Error('Worker error: ' + error.message);
                    }
                }

                self.onmessage = async function(e) {
                    try {
                        const { colors, selectCount } = e.data;
                        const result = await processColors(colors, selectCount);
                        self.postMessage({
                            type: 'complete',
                            result: result
                        });
                    } catch (error) {
                        self.postMessage({
                            type: 'error',
                            error: error.message
                        });
                    }
                };
            `;

            const blob = new Blob([workerCode], { type: 'application/javascript' });
            return new Worker(URL.createObjectURL(blob));
        }

        // Add this new function to format execution times
        function formatExecutionTime(timeInMs) {
            if (timeInMs < 0.001) {
                // Convert to nanoseconds (ns)
                const timeInNs = timeInMs * 1000000;
                return `${timeInNs.toFixed(0)}ns`;
            } else if (timeInMs < 1) {
                // Convert to microseconds (µs)
                const timeInUs = timeInMs * 1000;
                return `${timeInUs.toFixed(1)}µs`;
            } else if (timeInMs < 1000) {
                // Show milliseconds (ms)
                return `${timeInMs.toFixed(2)}ms`;
            } else {
                // Show seconds (s)
                return `${(timeInMs / 1000).toFixed(2)}s`;
            }
        }

        // Method 5: K-Means++
        function kmeansppSelection(colors, selectCount) {
            console.log('Starting K-Means++ calculation...');
            const start = performance.now();
            const labColors = colors.map(rgb2lab);
            
            // Initialize centers using k-means++ initialization
            const centers = [Math.floor(Math.random() * colors.length)];
            
            while (centers.length < selectCount) {
                const distances = new Array(colors.length).fill(0);
                
                // Calculate minimum distances to existing centers
                for (let i = 0; i < colors.length; i++) {
                    if (centers.includes(i)) continue;
                    let minDist = Infinity;
                    for (const center of centers) {
                        const dist = deltaE(labColors[i], labColors[center]);
                        minDist = Math.min(minDist, dist);
                    }
                    distances[i] = minDist * minDist; // Square distances for weighted probability
                }
                
                // Select next center probabilistically
                const sum = distances.reduce((a, b) => a + b, 0);
                let rand = Math.random() * sum;
                let nextCenter = 0;
                while (rand > 0) {
                    if (!centers.includes(nextCenter)) {
                        rand -= distances[nextCenter];
                    }
                    nextCenter++;
                }
                centers.push(nextCenter - 1);
            }
            
            console.log('K-Means++ calculation complete');
            return {
                colors: sortColors(centers.map(i => colors[i])),
                time: performance.now() - start
            };
        }

        // Method 6: Genetic Algorithm
        function geneticAlgorithm(colors, selectCount) {
            console.log('Starting Genetic Algorithm calculation...');
            const start = performance.now();
            const labColors = colors.map(rgb2lab);
            
            const populationSize = parseInt(document.getElementById('populationSize').value);
            const generations = parseInt(document.getElementById('generations').value);
            const mutationRate = parseFloat(document.getElementById('mutationRate').value);
            
            // Initialize population
            let population = [];
            for (let i = 0; i < populationSize; i++) {
                const chromosome = [];
                while (chromosome.length < selectCount) {
                    const gene = Math.floor(Math.random() * colors.length);
                    if (!chromosome.includes(gene)) chromosome.push(gene);
                }
                population.push(chromosome);
            }
            
            // Fitness function - minimum distance between any two colors
            function fitness(chromosome) {
                let minDist = Infinity;
                for (let i = 0; i < chromosome.length; i++) {
                    for (let j = i + 1; j < chromosome.length; j++) {
                        const dist = deltaE(labColors[chromosome[i]], labColors[chromosome[j]]);
                        minDist = Math.min(minDist, dist);
                    }
                }
                return minDist;
            }
            
            // Evolution
            for (let gen = 0; gen < generations; gen++) {
                // Selection and crossover
                const newPopulation = [];
                while (newPopulation.length < populationSize) {
                    // Tournament selection
                    const parent1 = population[Math.floor(Math.random() * population.length)];
                    const parent2 = population[Math.floor(Math.random() * population.length)];
                    
                    // Crossover
                    const crossoverPoint = Math.floor(Math.random() * selectCount);
                    const child = [...new Set([
                        ...parent1.slice(0, crossoverPoint),
                        ...parent2.slice(crossoverPoint)
                    ])];
                    
                    // Fill missing genes if needed
                    while (child.length < selectCount) {
                        const gene = Math.floor(Math.random() * colors.length);
                        if (!child.includes(gene)) child.push(gene);
                    }
                    
                    // Mutation
                    if (Math.random() < mutationRate) {
                        const pos = Math.floor(Math.random() * selectCount);
                        let newGene;
                        do {
                            newGene = Math.floor(Math.random() * colors.length);
                        } while (child.includes(newGene));
                        child[pos] = newGene;
                    }
                    
                    newPopulation.push(child);
                }
                
                population = newPopulation;
            }
            
            // Find best solution
            const best = population.reduce((a, b) => fitness(a) > fitness(b) ? a : b);
            
            console.log('Genetic Algorithm calculation complete');
            return {
                colors: sortColors(best.map(i => colors[i])),
                time: performance.now() - start
            };
        }

        // Method 7: Particle Swarm Optimization
        function particleSwarmOptimization(colors, selectCount) {
            console.log('Starting PSO calculation...');
            const start = performance.now();
            const labColors = colors.map(rgb2lab);
            
            const numParticles = parseInt(document.getElementById('numParticles').value);
            const iterations = parseInt(document.getElementById('psoIterations').value);
            const w = 0.7; // Inertia weight
            const c1 = 2.0; // Cognitive parameter
            const c2 = 2.0; // Social parameter
            
            // Initialize particles
            let particles = [];
            for (let i = 0; i < numParticles; i++) {
                const position = [];
                while (position.length < selectCount) {
                    const color = Math.floor(Math.random() * colors.length);
                    if (!position.includes(color)) position.push(color);
                }
                particles.push({
                    position: position,
                    velocity: new Array(selectCount).fill(0),
                    personalBest: position.slice(),
                    personalBestFitness: -Infinity
                });
            }
            
            let globalBest = particles[0].position.slice();
            let globalBestFitness = -Infinity;
            
            // Fitness function
            function fitness(position) {
                let minDist = Infinity;
                for (let i = 0; i < position.length; i++) {
                    for (let j = i + 1; j < position.length; j++) {
                        const dist = deltaE(labColors[position[i]], labColors[position[j]]);
                        minDist = Math.min(minDist, dist);
                    }
                }
                return minDist;
            }
            
            // PSO iterations
            for (let iter = 0; iter < iterations; iter++) {
                for (let particle of particles) {
                    // Update velocity and position
                    for (let d = 0; d < selectCount; d++) {
                        const r1 = Math.random();
                        const r2 = Math.random();
                        
                        particle.velocity[d] = Math.floor(
                            w * particle.velocity[d] +
                            c1 * r1 * (particle.personalBest[d] - particle.position[d]) +
                            c2 * r2 * (globalBest[d] - particle.position[d])
                        );
                        
                        // Apply velocity with boundary checking
                        const newPos = particle.position[d] + particle.velocity[d];
                        if (newPos >= 0 && newPos < colors.length && 
                            !particle.position.includes(newPos)) {
                            particle.position[d] = newPos;
                        }
                    }
                    
                    // Evaluate fitness
                    const currentFitness = fitness(particle.position);
                    
                    // Update personal best
                    if (currentFitness > particle.personalBestFitness) {
                        particle.personalBest = particle.position.slice();
                        particle.personalBestFitness = currentFitness;
                        
                        // Update global best
                        if (currentFitness > globalBestFitness) {
                            globalBest = particle.position.slice();
                            globalBestFitness = currentFitness;
                        }
                    }
                }
            }
            
            console.log('PSO calculation complete');
            return {
                colors: sortColors(globalBest.map(i => colors[i])),
                time: performance.now() - start
            };
        }

        // Method 8: Ant Colony Optimization
        function antColonyOptimization(colors, selectCount) {
            console.log('Starting ACO calculation...');
            const start = performance.now();
            const labColors = colors.map(rgb2lab);
            
            const numAnts = parseInt(document.getElementById('numAnts').value);
            const iterations = parseInt(document.getElementById('acoIterations').value);
            const evaporationRate = 0.1;
            const alpha = 1; // Pheromone importance
            const beta = 2;  // Heuristic importance
            
            // Initialize pheromone matrix
            const pheromone = Array(colors.length).fill(0).map(() => 
                Array(colors.length).fill(1.0)
            );
            
            // Heuristic information (color distances)
            const heuristic = Array(colors.length).fill(0).map((_, i) => 
                Array(colors.length).fill(0).map((_, j) => 
                    i === j ? 0 : deltaE(labColors[i], labColors[j])
                )
            );
            
            let bestSolution = null;
            let bestFitness = -Infinity;
            
            // ACO iterations
            for (let iter = 0; iter < iterations; iter++) {
                const solutions = [];
                
                // Each ant constructs a solution
                for (let ant = 0; ant < numAnts; ant++) {
                    const solution = [Math.floor(Math.random() * colors.length)];
                    
                    // Construct solution
                    while (solution.length < selectCount) {
                        const probabilities = [];
                        let total = 0;
                        
                        // Calculate probabilities for each possible next color
                        for (let i = 0; i < colors.length; i++) {
                            if (solution.includes(i)) continue;
                            
                            let pheromoneProduct = 1;
                            let heuristicSum = 0;
                            
                            for (const j of solution) {
                                pheromoneProduct *= Math.pow(pheromone[j][i], alpha);
                                heuristicSum += Math.pow(heuristic[j][i], beta);
                            }
                            
                            const probability = pheromoneProduct * heuristicSum;
                            probabilities.push({ index: i, prob: probability });
                            total += probability;
                        }
                        
                        // Select next color using roulette wheel selection
                        let rand = Math.random() * total;
                        let nextColor = probabilities[0].index;
                        for (const { index, prob } of probabilities) {
                            rand -= prob;
                            if (rand <= 0) {
                                nextColor = index;
                                break;
                            }
                        }
                        
                        solution.push(nextColor);
                    }
                    
                    solutions.push(solution);
                    
                    // Evaluate solution
                    const fitness = Math.min(...solution.map((i, idx) =>
                        solution.slice(idx + 1).map(j =>
                            deltaE(labColors[i], labColors[j])
                        )
                    ).flat());
                    
                    if (fitness > bestFitness) {
                        bestFitness = fitness;
                        bestSolution = solution.slice();
                    }
                }
                
                // Pheromone evaporation
                for (let i = 0; i < colors.length; i++) {
                    for (let j = 0; j < colors.length; j++) {
                        pheromone[i][j] *= (1 - evaporationRate);
                    }
                }
                
                // Pheromone deposit
                for (const solution of solutions) {
                    const deposit = 1.0 / solution.length;
                    for (let i = 0; i < solution.length - 1; i++) {
                        for (let j = i + 1; j < solution.length; j++) {
                            pheromone[solution[i]][solution[j]] += deposit;
                            pheromone[solution[j]][solution[i]] += deposit;
                        }
                    }
                }
            }
            
            console.log('ACO calculation complete');
            return {
                colors: sortColors(bestSolution.map(i => colors[i])),
                time: performance.now() - start
            };
        }

        // Method 9: Tabu Search
        function tabuSearch(colors, selectCount) {
            console.log('Starting Tabu Search calculation...');
            const start = performance.now();
            const labColors = colors.map(rgb2lab);
            
            const maxIterations = parseInt(document.getElementById('tabuIterations').value);
            const tabuTenure = parseInt(document.getElementById('tabuTenure').value);
            
            // Initialize solution
            let current = Array.from({length: selectCount}, (_, i) => i);
            let best = current.slice();
            let bestFitness = evaluateSolution(best);
            
            // Tabu list implementation using a Map to store move expiration
            const tabuList = new Map();
            
            // Evaluate solution fitness (minimum distance between any two colors)
            function evaluateSolution(solution) {
                let minDist = Infinity;
                for (let i = 0; i < solution.length; i++) {
                    for (let j = i + 1; j < solution.length; j++) {
                        const dist = deltaE(labColors[solution[i]], labColors[solution[j]]);
                        minDist = Math.min(minDist, dist);
                    }
                }
                return minDist;
            }
            
            // Generate move key for tabu list
            function getMoveKey(oldColor, newColor) {
                return `${oldColor}-${newColor}`;
            }
            
            for (let iter = 0; iter < maxIterations; iter++) {
                let bestNeighborSolution = null;
                let bestNeighborFitness = -Infinity;
                
                // Examine all possible moves
                for (let i = 0; i < selectCount; i++) {
                    for (let j = 0; j < colors.length; j++) {
                        if (!current.includes(j)) {
                            const moveKey = getMoveKey(current[i], j);
                            const neighbor = current.slice();
                            neighbor[i] = j;
                            
                            const fitness = evaluateSolution(neighbor);
                            
                            // Accept if better than current best neighbor and not tabu
                            // or if satisfies aspiration criterion (better than global best)
                            if ((fitness > bestNeighborFitness && 
                                 (!tabuList.has(moveKey) || tabuList.get(moveKey) <= iter)) ||
                                fitness > bestFitness) {
                                bestNeighborSolution = neighbor;
                                bestNeighborFitness = fitness;
                            }
                        }
                    }
                }
                
                if (!bestNeighborSolution) break;
                
                // Update current solution
                current = bestNeighborSolution;
                
                // Update best solution if improved
                if (bestNeighborFitness > bestFitness) {
                    best = current.slice();
                    bestFitness = bestNeighborFitness;
                }
                
                // Update tabu list
                for (let i = 0; i < selectCount; i++) {
                    const moveKey = getMoveKey(current[i], best[i]);
                    tabuList.set(moveKey, iter + tabuTenure);
                }
                
                // Clean expired tabu moves
                for (const [move, expiration] of tabuList.entries()) {
                    if (expiration <= iter) {
                        tabuList.delete(move);
                    }
                }
            }
            
            console.log('Tabu Search calculation complete');
            return {
                colors: sortColors(best.map(i => colors[i])),
                time: performance.now() - start
            };
        }

        // Add this function after initializePage
        function toggleSettings(button) {
            button.classList.toggle('active');
            button.closest('.input-group').querySelector('.settings-container').classList.toggle('show');
            button.textContent = button.classList.contains('active') ? 'Hide Settings' : 'Show Settings';
        }

        // The existing event listener can stay as is
        document.addEventListener('DOMContentLoaded', initializePage);

        // First, add this new function to handle dynamic rankings
        function updateRankings() {
            let summaryContainer = document.querySelector('.algorithm-section[data-type="summary"]');
            if (!summaryContainer) {
                summaryContainer = document.createElement('div');
                summaryContainer.className = 'algorithm-section';
                summaryContainer.setAttribute('data-type', 'summary');
                summaryContainer.innerHTML = '<h2>Rankings (Highest minimum deltaE)</h2>';
                document.getElementById('results').appendChild(summaryContainer);
            }

            // Collect results from all algorithms
            const allResults = [];
            document.querySelectorAll('.algorithm-section').forEach(section => {
                if (section.getAttribute('data-type') === 'summary') return;
                
                const titleElement = section.querySelector('h2');
                if (titleElement) {
                    const algorithmName = titleElement.textContent;
                    const metricsText = Array.from(section.querySelectorAll('p'));
                    
                    // Extract minimum deltaE
                    const deltaEText = metricsText.find(p => p.textContent.includes('Minimum deltaE'))?.textContent || '';
                    const minDeltaE = parseFloat(deltaEText.split(':')[1]) || 0;
                    
                    // Extract execution time
                    const timeText = metricsText.find(p => p.textContent.includes('Execution time'))?.textContent || '';
                    const executionTime = timeText.split(':')[1]?.trim() || 'N/A';
                    
                    // Extract RGB values from the color swatches
                    const colors = Array.from(section.querySelectorAll('.swatch'))
                        .slice(0, parseInt(document.getElementById('selectColors').value))
                        .map(swatch => {
                            const style = window.getComputedStyle(swatch);
                            const rgb = style.backgroundColor.match(/\d+/g).map(Number);
                            return rgb;
                        });
                    
                    if (colors.length > 0) {
                        allResults.push({
                            name: algorithmName,
                            minDeltaE: minDeltaE,
                            executionTime: executionTime,
                            colors: sortColors(colors)
                        });
                    }
                }
            });

            if (allResults.length >= 2) {
                // Sort results by minimum deltaE (descending)
                allResults.sort((a, b) => b.minDeltaE - a.minDeltaE);

                // Assign ranks, handling ties
                let currentRank = 1;
                let currentDeltaE = allResults[0].minDeltaE;
                allResults[0].rank = currentRank;

                for (let i = 1; i < allResults.length; i++) {
                    if (allResults[i].minDeltaE === currentDeltaE) {
                        allResults[i].rank = currentRank;
                    } else {
                        currentRank = i + 1;
                        currentDeltaE = allResults[i].minDeltaE;
                        allResults[i].rank = currentRank;
                    }
                }

                // Create the summary HTML with sorted colors and execution time
                const summaryHTML = `
                    <h2>Rankings (Highest minimum deltaE)</h2>
                    <div style="font-family: monospace;">
                        ${allResults.map(result => {
                            const deltaEString = result.minDeltaE.toFixed(2);
                            const paddedDeltaE = deltaEString.length < 5 ? ' ' + deltaEString : deltaEString;
                            
                            return `
                                <div style="display: flex; align-items: center; margin: 10px 0;">
                                    <div style="width: 30px; font-weight: bold;">#${result.rank}</div>
                                    <div style="width: 200px;">${result.name}</div>
                                    <div style="margin-right: 20px; width: 80px;">deltaE: ${paddedDeltaE}</div>
                                    <div style="margin-right: 20px; width: 120px;">Time: ${result.executionTime}</div>
                                    <div class="swatch-container">
                                        ${result.colors.map(rgb => 
                                            `<div class="swatch" style="background-color: rgb(${rgb.join(',')}"></div>`
                                        ).join('')}
                                    </div>
                                </div>
                            `;
                        }).join('')}
                    </div>
                `;

                summaryContainer.innerHTML = summaryHTML;
            }
        }
    </script>
</body>
</html>
